datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

model User {
  id                     Int       @id @default(autoincrement())
  email                  String    @unique
  password               String
  name                   String?
  location               String?
  trustScore             Float     @default(5.0)
  role                   Role      @default(USER)
  isEmailVerified        Boolean   @default(false)
  emailVerificationToken String?   @unique
  createdAt              DateTime  @default(now())
  updatedAt              DateTime  @updatedAt
  deletedAt              DateTime?

  wardrobeItems        WardrobeItem[]
  rentOrders           Order[]            @relation("RenterOrders")
  ownerOrders          Order[]            @relation("OwnerOrders")
  reviewsGiven         Review[]           @relation("Reviewer")
  reviewsRecv          Review[]           @relation("Reviewee")
  userSubscription     UserSubscription?
  itemsInCustody       WardrobeItem[]     @relation("CurrentHolder")
  auditLogs            AuditLog[]
  disputes             Dispute[]
  adminActions         AdminOverrideLog[] @relation("AdminActions")
  validatorAssignments Validation[]       @relation("ValidatorAssignments")

  @@index([email])
  @@index([deletedAt])
}

model WardrobeItem {
  id      Int  @id @default(autoincrement())
  ownerId Int
  owner   User @relation(fields: [ownerId], references: [id])

  // Basic info
  title       String
  description String?
  category    String
  brand       String?
  size        String?
  condition   ItemCondition
  images      String[]      @default([])

  // Availability - CRITICAL: Default to PERSONAL_ONLY
  availability    ItemAvailability @default(PERSONAL_ONLY)
  rentPricePerDay Float?
  sellPrice       Float?

  // Tracking
  wearCount Int       @default(0)
  viewCount Int       @default(0)
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  deletedAt DateTime?

  // Custody tracking
  currentHolderId  Int?
  currentHolder    User?     @relation("CurrentHolder", fields: [currentHolderId], references: [id])
  custodyStartDate DateTime?
  custodyEndDate   DateTime?

  orders           Order[]
  wearLogs         WearLog[]
  conditionHistory ItemConditionHistory[]
  validations      Validation[]

  @@index([ownerId])
  @@index([availability]) // For marketplace queries
  @@index([currentHolderId])
  @@index([deletedAt])
}

enum ItemAvailability {
  PERSONAL_ONLY // Never shown in marketplace
  AVAILABLE_FOR_RENT
  AVAILABLE_FOR_SALE
  AVAILABLE_FOR_SWAP
}

enum ItemCondition {
  NEW
  LIKE_NEW
  GOOD
  FAIR
  WORN
}

model Order {
  id             Int          @id @default(autoincrement())
  renterId       Int
  renter         User         @relation("RenterOrders", fields: [renterId], references: [id])
  ownerId        Int
  owner          User         @relation("OwnerOrders", fields: [ownerId], references: [id])
  itemId         Int
  item           WardrobeItem @relation(fields: [itemId], references: [id])
  type           OrderType
  status         OrderStatus  @default(REQUESTED)
  previousStatus OrderStatus?
  startDate      DateTime?
  endDate        DateTime?
  totalPrice     Float?
  createdAt      DateTime     @default(now())
  updatedAt      DateTime     @updatedAt
  deletedAt      DateTime?

  // Idempotency
  idempotencyKey String? @unique

  // SLA timers
  expiresAt DateTime?
  isLate    Boolean   @default(false)

  // Optimistic locking
  version Int @default(1)

  // Validation gate
  requiresValidation Boolean @default(false)

  reviews          Review[]
  disputes         Dispute[]
  conditionHistory ItemConditionHistory[]
  payments         Payment[]
  validation       Validation?
  delivery         Delivery?

  @@index([itemId, startDate, endDate])
  @@index([renterId])
  @@index([ownerId])
  @@index([idempotencyKey])
  @@index([deletedAt])
  @@index([version])
  @@index([status])
}

enum OrderType {
  RENT
  SWAP
  SELL
}

enum OrderStatus {
  REQUESTED
  PENDING_VALIDATION
  APPROVED
  PAID
  DISPATCHED
  IN_TRANSIT
  DELIVERED
  RETURN_REQUESTED
  RETURNED
  COMPLETED
  CANCELLED
}

model WearLog {
  id       Int          @id @default(autoincrement())
  itemId   Int
  item     WardrobeItem @relation(fields: [itemId], references: [id])
  wornDate DateTime     @default(now())
}

model Review {
  id         Int      @id @default(autoincrement())
  orderId    Int
  order      Order    @relation(fields: [orderId], references: [id])
  reviewerId Int
  reviewer   User     @relation("Reviewer", fields: [reviewerId], references: [id])
  revieweeId Int
  reviewee   User     @relation("Reviewee", fields: [revieweeId], references: [id])
  rating     Int // 1-5
  comment    String?
  createdAt  DateTime @default(now())
  // NO updatedAt - reviews are IMMUTABLE

  @@unique([orderId, reviewerId]) // One review per user per order
  @@index([revieweeId])
  @@index([orderId])
}

// STEP 4: Validation as a Gate
model Validation {
  id          Int          @id @default(autoincrement())
  orderId     Int          @unique
  order       Order        @relation(fields: [orderId], references: [id])
  itemId      Int
  item        WardrobeItem @relation(fields: [itemId], references: [id])
  validatorId Int?
  validator   User?        @relation("ValidatorAssignments", fields: [validatorId], references: [id])

  status ValidationStatus @default(PENDING)
  reason String? // Why validation is required
  notes  String? // Validator notes

  createdAt  DateTime  @default(now())
  approvedAt DateTime?
  rejectedAt DateTime?

  @@index([orderId])
  @@index([validatorId])
  @@index([status])
}

enum ValidationStatus {
  PENDING
  APPROVED
  REJECTED
}

// STEP 5: Basic Delivery Tracking
model Delivery {
  id      Int   @id @default(autoincrement())
  orderId Int   @unique
  order   Order @relation(fields: [orderId], references: [id])

  status         DeliveryStatus @default(PENDING)
  trackingNumber String?
  notes          String?

  pickedUpAt  DateTime?
  deliveredAt DateTime?
  failedAt    DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([status])
}

enum DeliveryStatus {
  PENDING
  PICKED_UP
  IN_TRANSIT
  DELIVERED
  FAILED
}

// New models for production features

model ItemConditionHistory {
  id              Int          @id @default(autoincrement())
  itemId          Int
  item            WardrobeItem @relation(fields: [itemId], references: [id])
  orderId         Int?
  order           Order?       @relation(fields: [orderId], references: [id])
  conditionBefore String
  conditionAfter  String
  damageReport    String?
  reportedBy      Int
  timestamp       DateTime     @default(now())

  @@index([itemId])
  @@index([orderId])
}

model AuditLog {
  id         Int      @id @default(autoincrement())
  entityType String
  entityId   Int
  action     String
  userId     Int?
  user       User?    @relation(fields: [userId], references: [id])
  oldValue   String?
  newValue   String?
  timestamp  DateTime @default(now())

  @@index([entityType, entityId])
  @@index([userId])
}

model Subscription {
  id          Int      @id @default(autoincrement())
  name        String   @unique
  rentalLimit Int
  swapCredits Int
  price       Float
  createdAt   DateTime @default(now())

  userSubscriptions UserSubscription[]
}

model UserSubscription {
  id             Int          @id @default(autoincrement())
  userId         Int          @unique
  user           User         @relation(fields: [userId], references: [id])
  subscriptionId Int
  subscription   Subscription @relation(fields: [subscriptionId], references: [id])
  cycleStart     DateTime
  cycleEnd       DateTime
  rentalsUsed    Int          @default(0)
  swapsUsed      Int          @default(0)
  createdAt      DateTime     @default(now())
  updatedAt      DateTime     @updatedAt

  @@index([userId])
}

model Dispute {
  id         Int           @id @default(autoincrement())
  orderId    Int
  order      Order         @relation(fields: [orderId], references: [id])
  raisedById Int
  raisedBy   User          @relation(fields: [raisedById], references: [id])
  reason     String
  status     DisputeStatus @default(OPEN)
  resolution String?
  createdAt  DateTime      @default(now())
  resolvedAt DateTime?

  @@index([orderId])
}

enum DisputeStatus {
  OPEN
  INVESTIGATING
  RESOLVED
  CLOSED
}

enum Role {
  USER
  VALIDATOR
  ADMIN
  SUPER_ADMIN
}

model Payment {
  id               Int           @id @default(autoincrement())
  orderId          Int
  order            Order         @relation(fields: [orderId], references: [id])
  amount           Float
  currency         String        @default("INR")
  status           PaymentStatus @default(PENDING)
  paymentMethod    String?
  gatewayOrderId   String?       @unique
  gatewayPaymentId String?       @unique
  authorizedAt     DateTime?
  capturedAt       DateTime?
  failedAt         DateTime?
  refundedAt       DateTime?
  refundAmount     Float?
  createdAt        DateTime      @default(now())
  updatedAt        DateTime      @updatedAt

  @@index([orderId])
  @@index([gatewayOrderId])
  @@index([gatewayPaymentId])
}

enum PaymentStatus {
  PENDING
  AUTHORIZED
  CAPTURED
  FAILED
  REFUNDED
  PARTIALLY_REFUNDED
}

model AdminOverrideLog {
  id         Int      @id @default(autoincrement())
  adminId    Int
  admin      User     @relation("AdminActions", fields: [adminId], references: [id])
  action     String
  entityType String
  entityId   Int
  reason     String
  metadata   String?
  createdAt  DateTime @default(now())

  @@index([adminId])
  @@index([entityType, entityId])
}

model RecommendationFeedback {
  id               Int            @id @default(autoincrement())
  recommendationId Int            @unique
  userId           Int
  action           FeedbackAction
  createdAt        DateTime       @default(now())

  @@index([userId])
}

enum FeedbackAction {
  ACCEPTED
  IGNORED
  DISMISSED
}
