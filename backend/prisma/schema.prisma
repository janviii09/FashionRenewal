datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

model User {
  id                     Int       @id @default(autoincrement())
  email                  String    @unique
  password               String
  name                   String?
  location               String?
  trustScore             Float     @default(5.0)
  role                   Role      @default(USER)
  isEmailVerified        Boolean   @default(false)
  emailVerificationToken String?   @unique
  createdAt              DateTime  @default(now())
  updatedAt              DateTime  @updatedAt
  deletedAt              DateTime?

  // Verification status (denormalized for performance)
  phoneVerified Boolean @default(false)
  idVerified    Boolean @default(false)
  trustedLender Boolean @default(false)

  // Risk flags
  disputeRiskScore Decimal?  @db.Decimal(3, 2)
  flaggedAt        DateTime?
  flagReason       String?

  wardrobeItems        WardrobeItem[]
  rentOrders           Order[]            @relation("RenterOrders")
  ownerOrders          Order[]            @relation("OwnerOrders")
  reviewsGiven         Review[]           @relation("Reviewer")
  reviewsRecv          Review[]           @relation("Reviewee")
  userSubscription     UserSubscription?
  itemsInCustody       WardrobeItem[]     @relation("CurrentHolder")
  auditLogs            AuditLog[]
  disputes             Dispute[]
  adminActions         AdminOverrideLog[] @relation("AdminActions")
  validatorAssignments Validation[]       @relation("ValidatorAssignments")

  // User activity tracking relations
  activities     UserActivity[]   @relation("UserActivities")
  affinity       UserAffinity?    @relation("UserAffinities")
  recentlyViewed RecentlyViewed[] @relation("RecentlyViewedByUser")

  // Dispute relations
  disputesRaised   Dispute[]         @relation("DisputesRaised")
  disputesAgainst  Dispute[]         @relation("DisputesAgainst")
  disputesResolved Dispute[]         @relation("DisputesResolved")
  disputeEvidence  DisputeEvidence[] @relation("DisputeEvidenceUploads")
  disputeResponses DisputeResponse[] @relation("DisputeResponses")
  disputeTimeline  DisputeTimeline[] @relation("DisputeTimelineActor")

  // Verification relations
  verifications         UserVerification[]    @relation("UserVerifications")
  verificationsReviewed UserVerification[]    @relation("VerificationsReviewed")
  trustedLenderMetrics  TrustedLenderMetrics? @relation("TrustedLenderMetrics")

  // Cart relation
  cart Cart? @relation("UserCart")

  @@index([email])
  @@index([deletedAt])
}

model WardrobeItem {
  id      Int  @id @default(autoincrement())
  ownerId Int
  owner   User @relation(fields: [ownerId], references: [id])

  // Basic info
  title       String
  description String?
  category    String
  brand       String?
  size        String?
  condition   ItemCondition
  images      String[]      @default([])

  // Availability - CRITICAL: Default to PERSONAL_ONLY
  availability    ItemAvailability @default(PERSONAL_ONLY)
  rentPricePerDay Float?
  sellPrice       Float?

  // Tracking
  wearCount Int       @default(0)
  viewCount Int       @default(0)
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  deletedAt DateTime?

  // NEW: Trending and sorting fields for Browse/Discover optimization
  trendingScore Float     @default(0) // Computed score for trending items
  rentalCount   Int       @default(0) // Number of times rented
  purchaseCount Int       @default(0) // Number of times purchased
  wishlistCount Int       @default(0) // Number of times added to wishlist
  lastRentedAt  DateTime? // Last rental date

  // Custody tracking
  currentHolderId  Int?
  currentHolder    User?     @relation("CurrentHolder", fields: [currentHolderId], references: [id])
  custodyStartDate DateTime?
  custodyEndDate   DateTime?

  orders           Order[]
  wearLogs         WearLog[]
  conditionHistory ItemConditionHistory[]
  validations      Validation[]

  // Cart relation
  cartItems CartItem[] @relation("CartItems")

  // Activity tracking relations
  activities     UserActivity[]   @relation("ItemActivities")
  recentlyViewed RecentlyViewed[] @relation("RecentlyViewedItems")

  @@index([ownerId])
  @@index([availability]) // For marketplace queries
  @@index([currentHolderId])
  @@index([deletedAt])
  // NEW: Performance indexes for Browse/Discover
  @@index([trendingScore])
  @@index([rentalCount])
  @@index([createdAt])
  @@index([category, availability])
  @@index([rentPricePerDay])
  @@index([sellPrice])
}

enum ItemAvailability {
  PERSONAL_ONLY // Never shown in marketplace
  AVAILABLE_FOR_RENT
  AVAILABLE_FOR_SALE
  AVAILABLE_FOR_SWAP
}

enum ItemCondition {
  NEW
  LIKE_NEW
  GOOD
  FAIR
  WORN
}

// ============================================
// CART SYSTEM
// ============================================

model Cart {
  id        Int        @id @default(autoincrement())
  userId    Int        @unique
  user      User       @relation("UserCart", fields: [userId], references: [id], onDelete: Cascade)
  items     CartItem[]
  createdAt DateTime   @default(now())
  updatedAt DateTime   @updatedAt

  @@index([userId])
}

model CartItem {
  id        Int          @id @default(autoincrement())
  cartId    Int
  cart      Cart         @relation(fields: [cartId], references: [id], onDelete: Cascade)
  itemId    Int
  item      WardrobeItem @relation("CartItems", fields: [itemId], references: [id], onDelete: Cascade)
  type      String       // 'rent' or 'buy'
  quantity  Int          @default(1)
  dateFrom  DateTime?    // For rent items
  dateTo    DateTime?    // For rent items
  createdAt DateTime     @default(now())
  updatedAt DateTime     @updatedAt

  @@unique([cartId, itemId])
  @@index([cartId])
  @@index([itemId])
}

model Order {
  id             Int          @id @default(autoincrement())
  renterId       Int
  renter         User         @relation("RenterOrders", fields: [renterId], references: [id])
  ownerId        Int
  owner          User         @relation("OwnerOrders", fields: [ownerId], references: [id])
  itemId         Int
  item           WardrobeItem @relation(fields: [itemId], references: [id])
  type           OrderType
  status         OrderStatus  @default(REQUESTED)
  previousStatus OrderStatus?
  startDate      DateTime?
  endDate        DateTime?
  totalPrice     Float?
  createdAt      DateTime     @default(now())
  updatedAt      DateTime     @updatedAt
  deletedAt      DateTime?

  // Idempotency
  idempotencyKey String? @unique

  // SLA timers
  expiresAt DateTime?
  isLate    Boolean   @default(false)

  // Optimistic locking
  version Int @default(1)

  // Validation gate
  requiresValidation Boolean @default(false)

  // Dispute tracking
  hasActiveDispute Boolean   @default(false)
  disputeCount     Int       @default(0)
  disputeLockedAt  DateTime?

  reviews          Review[]
  orderDisputes    Dispute[]              @relation("OrderDisputes")
  conditionHistory ItemConditionHistory[]
  payments         Payment[]
  validation       Validation?
  delivery         Delivery?

  @@index([itemId, startDate, endDate])
  @@index([renterId])
  @@index([ownerId])
  @@index([idempotencyKey])
  @@index([deletedAt])
  @@index([version])
  @@index([status])
}

enum OrderType {
  RENT
  SWAP
  SELL
}

enum OrderStatus {
  REQUESTED
  PENDING_VALIDATION
  APPROVED
  PAID
  DISPATCHED
  IN_TRANSIT
  DELIVERED
  RETURN_REQUESTED
  RETURNED
  COMPLETED
  CANCELLED
}

model WearLog {
  id       Int          @id @default(autoincrement())
  itemId   Int
  item     WardrobeItem @relation(fields: [itemId], references: [id])
  wornDate DateTime     @default(now())
}

model Review {
  id         Int      @id @default(autoincrement())
  orderId    Int
  order      Order    @relation(fields: [orderId], references: [id])
  reviewerId Int
  reviewer   User     @relation("Reviewer", fields: [reviewerId], references: [id])
  revieweeId Int
  reviewee   User     @relation("Reviewee", fields: [revieweeId], references: [id])
  rating     Int // 1-5
  comment    String?
  createdAt  DateTime @default(now())
  // NO updatedAt - reviews are IMMUTABLE

  @@unique([orderId, reviewerId]) // One review per user per order
  @@index([revieweeId])
  @@index([orderId])
}

// STEP 4: Validation as a Gate
model Validation {
  id          Int          @id @default(autoincrement())
  orderId     Int          @unique
  order       Order        @relation(fields: [orderId], references: [id])
  itemId      Int
  item        WardrobeItem @relation(fields: [itemId], references: [id])
  validatorId Int?
  validator   User?        @relation("ValidatorAssignments", fields: [validatorId], references: [id])

  status ValidationStatus @default(PENDING)
  reason String? // Why validation is required
  notes  String? // Validator notes

  createdAt  DateTime  @default(now())
  approvedAt DateTime?
  rejectedAt DateTime?

  @@index([orderId])
  @@index([validatorId])
  @@index([status])
}

enum ValidationStatus {
  PENDING
  APPROVED
  REJECTED
}

// STEP 5: Basic Delivery Tracking
model Delivery {
  id      Int   @id @default(autoincrement())
  orderId Int   @unique
  order   Order @relation(fields: [orderId], references: [id])

  status         DeliveryStatus @default(PENDING)
  trackingNumber String?
  notes          String?

  pickedUpAt  DateTime?
  deliveredAt DateTime?
  failedAt    DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([status])
}

enum DeliveryStatus {
  PENDING
  PICKED_UP
  IN_TRANSIT
  DELIVERED
  FAILED
}

// New models for production features

model ItemConditionHistory {
  id              Int          @id @default(autoincrement())
  itemId          Int
  item            WardrobeItem @relation(fields: [itemId], references: [id])
  orderId         Int?
  order           Order?       @relation(fields: [orderId], references: [id])
  conditionBefore String
  conditionAfter  String
  damageReport    String?
  reportedBy      Int
  timestamp       DateTime     @default(now())

  @@index([itemId])
  @@index([orderId])
}

model AuditLog {
  id         Int      @id @default(autoincrement())
  entityType String
  entityId   Int
  action     String
  userId     Int?
  user       User?    @relation(fields: [userId], references: [id])
  oldValue   String?
  newValue   String?
  timestamp  DateTime @default(now())

  @@index([entityType, entityId])
  @@index([userId])
}

model Subscription {
  id          Int      @id @default(autoincrement())
  name        String   @unique
  rentalLimit Int
  swapCredits Int
  price       Float
  createdAt   DateTime @default(now())

  userSubscriptions UserSubscription[]
}

model UserSubscription {
  id             Int          @id @default(autoincrement())
  userId         Int          @unique
  user           User         @relation(fields: [userId], references: [id])
  subscriptionId Int
  subscription   Subscription @relation(fields: [subscriptionId], references: [id])
  cycleStart     DateTime
  cycleEnd       DateTime
  rentalsUsed    Int          @default(0)
  swapsUsed      Int          @default(0)
  createdAt      DateTime     @default(now())
  updatedAt      DateTime     @updatedAt

  @@index([userId])
}

// Old Dispute model removed - replaced with comprehensive version below

enum Role {
  USER
  VALIDATOR
  ADMIN
  SUPER_ADMIN
}

model Payment {
  id               Int           @id @default(autoincrement())
  orderId          Int
  order            Order         @relation(fields: [orderId], references: [id])
  amount           Float
  currency         String        @default("INR")
  status           PaymentStatus @default(PENDING)
  paymentMethod    String?
  gatewayOrderId   String?       @unique
  gatewayPaymentId String?       @unique
  authorizedAt     DateTime?
  capturedAt       DateTime?
  failedAt         DateTime?
  refundedAt       DateTime?
  refundAmount     Float?
  createdAt        DateTime      @default(now())
  updatedAt        DateTime      @updatedAt

  @@index([orderId])
  @@index([gatewayOrderId])
  @@index([gatewayPaymentId])
}

enum PaymentStatus {
  PENDING
  AUTHORIZED
  CAPTURED
  FAILED
  REFUNDED
  PARTIALLY_REFUNDED
}

model AdminOverrideLog {
  id         Int      @id @default(autoincrement())
  adminId    Int
  admin      User     @relation("AdminActions", fields: [adminId], references: [id])
  action     String
  entityType String
  entityId   Int
  reason     String
  metadata   String?
  createdAt  DateTime @default(now())

  @@index([adminId])
  @@index([entityType, entityId])
}

model RecommendationFeedback {
  id               Int            @id @default(autoincrement())
  recommendationId Int            @unique
  userId           Int
  action           FeedbackAction
  createdAt        DateTime       @default(now())

  @@index([userId])
}

enum FeedbackAction {
  ACCEPTED
  IGNORED
  DISMISSED
}

// ═══════════════════════════════════════════════════════════════
// USER ACTIVITY TRACKING & RECOMMENDATIONS
// ═══════════════════════════════════════════════════════════════

model UserActivity {
  id        String       @id @default(cuid())
  userId    Int? // Nullable for guest users
  sessionId String? // For guest tracking
  eventType ActivityType
  itemId    Int?
  category  String?
  metadata  Json? // Flexible for future events
  createdAt DateTime     @default(now())

  // Relations
  user User?         @relation("UserActivities", fields: [userId], references: [id])
  item WardrobeItem? @relation("ItemActivities", fields: [itemId], references: [id])

  // Indexes for performance
  @@index([userId, createdAt])
  @@index([sessionId, createdAt])
  @@index([eventType, createdAt])
  @@index([itemId])
}

enum ActivityType {
  VIEW // Product page view
  CLICK // Item card click
  WISHLIST_ADD
  WISHLIST_REMOVE
  CART_ADD
  CART_REMOVE
  RENTAL_COMPLETE
  PURCHASE_COMPLETE
  SEARCH // Optional
}

model UserAffinity {
  id     String @id @default(cuid())
  userId Int    @unique

  // Category preferences (JSON for flexibility)
  categoryScores  Json @default("{}") // { "Women": 85, "Men": 15, ... }
  brandScores     Json @default("{}") // { "Fabindia": 90, "Zara": 70, ... }
  priceRangePrefs Json @default("{}") // { "min": 500, "max": 2000, "avg": 1200 }

  // Behavioral signals
  avgViewDuration Int? // Seconds
  conversionRate  Float? // Purchases / Views

  // Metadata
  lastComputed    DateTime @default(now())
  totalActivities Int      @default(0)

  // Relations
  user User @relation("UserAffinities", fields: [userId], references: [id])

  @@index([userId])
}

model RecentlyViewed {
  id        String   @id @default(cuid())
  userId    Int?
  sessionId String?
  itemId    Int
  viewedAt  DateTime @default(now())

  // Relations
  user User?        @relation("RecentlyViewedByUser", fields: [userId], references: [id])
  item WardrobeItem @relation("RecentlyViewedItems", fields: [itemId], references: [id])

  @@unique([userId, itemId])
  @@unique([sessionId, itemId])
  @@index([userId, viewedAt])
  @@index([sessionId, viewedAt])
}

// ============================================
// TRUST & SAFETY SYSTEMS
// ============================================

// Dispute Resolution System
enum DisputeReason {
  ITEM_NOT_AS_DESCRIBED
  ITEM_DAMAGED
  LATE_DELIVERY
  PAYMENT_ISSUE
  HARASSMENT
  FRAUD
  OTHER
}

enum DisputeStatus {
  OPEN // Initial state
  RESPONDED // Counterparty responded
  UNDER_REVIEW // Admin reviewing
  RESOLVED // Decision made
  CLOSED // Final state
  ESCALATED // Auto-escalated due to timeout
}

enum DisputeResolution {
  REFUND_FULL
  REFUND_PARTIAL
  NO_REFUND
  FORCE_COMPLETE
  PENALIZE_BUYER
  PENALIZE_SELLER
  MUTUAL_AGREEMENT
}

model Dispute {
  id Int @id @default(autoincrement())

  // Relationships
  orderId Int
  order   Order @relation("OrderDisputes", fields: [orderId], references: [id])

  raisedById Int // User who raised dispute
  raisedBy   User @relation("DisputesRaised", fields: [raisedById], references: [id])

  againstId Int // User being disputed
  against   User @relation("DisputesAgainst", fields: [againstId], references: [id])

  resolvedById Int? // Admin who resolved
  resolvedBy   User? @relation("DisputesResolved", fields: [resolvedById], references: [id])

  // Dispute Details
  reason      DisputeReason
  description String             @db.Text
  status      DisputeStatus      @default(OPEN)
  resolution  DisputeResolution?

  // SLA Tracking
  responseDeadline DateTime // Counterparty must respond by
  reviewDeadline   DateTime? // Admin must review by
  respondedAt      DateTime?
  escalatedAt      DateTime?
  resolvedAt       DateTime?
  closedAt         DateTime?

  // Resolution Details
  refundAmount Decimal? @db.Decimal(10, 2)
  adminNotes   String?  @db.Text

  // Trust Score Impact
  trustScoreImpact Json? // { raisedBy: -0.1, against: -0.5 }

  // Metadata
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  evidence  DisputeEvidence[]
  responses DisputeResponse[]
  timeline  DisputeTimeline[]
  User      User?             @relation(fields: [userId], references: [id])
  userId    Int?

  @@index([orderId])
  @@index([raisedById])
  @@index([againstId])
  @@index([status])
  @@index([createdAt])
  @@index([responseDeadline])
}

model DisputeEvidence {
  id        Int     @id @default(autoincrement())
  disputeId Int
  dispute   Dispute @relation(fields: [disputeId], references: [id], onDelete: Cascade)

  uploadedById Int
  uploadedBy   User @relation("DisputeEvidenceUploads", fields: [uploadedById], references: [id])

  fileUrl     String // Cloudinary/S3 URL
  fileType    String // image/jpeg, image/png
  fileSize    Int // bytes
  description String? @db.Text

  createdAt DateTime @default(now())

  @@index([disputeId])
}

model DisputeResponse {
  id        Int     @id @default(autoincrement())
  disputeId Int
  dispute   Dispute @relation(fields: [disputeId], references: [id], onDelete: Cascade)

  respondedById Int
  respondedBy   User @relation("DisputeResponses", fields: [respondedById], references: [id])

  message   String   @db.Text
  createdAt DateTime @default(now())

  @@index([disputeId])
}

model DisputeTimeline {
  id        Int     @id @default(autoincrement())
  disputeId Int
  dispute   Dispute @relation(fields: [disputeId], references: [id], onDelete: Cascade)

  actorId Int? // Null for system events
  actor   User? @relation("DisputeTimelineActor", fields: [actorId], references: [id])

  event       String // "DISPUTE_RAISED", "EVIDENCE_UPLOADED", "RESOLVED"
  description String @db.Text
  metadata    Json? // Additional context

  createdAt DateTime @default(now())

  @@index([disputeId])
  @@index([createdAt])
}

// User Verification System
enum VerificationType {
  EMAIL
  PHONE
  GOVERNMENT_ID
  TRUSTED_LENDER
}

enum VerificationStatus {
  PENDING
  VERIFIED
  REJECTED
  EXPIRED
  REVOKED
}

model UserVerification {
  id     Int  @id @default(autoincrement())
  userId Int
  user   User @relation("UserVerifications", fields: [userId], references: [id])

  type   VerificationType
  status VerificationStatus @default(PENDING)

  // Type-specific data (encrypted)
  verificationData Json? // Phone number, ID details, etc.

  // Verification metadata
  verifiedAt    DateTime?
  expiresAt     DateTime? // For time-limited verifications
  revokedAt     DateTime?
  revokedReason String?

  // Admin approval (for ID verification)
  reviewedById Int?
  reviewedBy   User?     @relation("VerificationsReviewed", fields: [reviewedById], references: [id])
  reviewedAt   DateTime?
  reviewNotes  String?   @db.Text

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  attempts VerificationAttempt[]

  @@unique([userId, type])
  @@index([userId])
  @@index([status])
  @@index([type])
}

model VerificationAttempt {
  id             Int              @id @default(autoincrement())
  verificationId Int
  verification   UserVerification @relation(fields: [verificationId], references: [id], onDelete: Cascade)

  attemptType   String // "OTP_SENT", "OTP_VERIFIED", "ID_SUBMITTED"
  success       Boolean
  failureReason String?
  metadata      Json? // IP, device info, etc.

  createdAt DateTime @default(now())

  @@index([verificationId])
  @@index([createdAt])
}

model TrustedLenderMetrics {
  id     Int  @id @default(autoincrement())
  userId Int  @unique
  user   User @relation("TrustedLenderMetrics", fields: [userId], references: [id])

  // Eligibility criteria
  successfulRentals Int       @default(0)
  totalRentals      Int       @default(0)
  lastDisputeDate   DateTime?
  accountAge        Int // days
  currentTrustScore Decimal   @db.Decimal(3, 2)

  // Badge status
  isEligible     Boolean   @default(false)
  badgeGrantedAt DateTime?
  badgeRevokedAt DateTime?

  // Recalculation tracking
  lastCalculatedAt  DateTime @default(now())
  nextCalculationAt DateTime

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([isEligible])
  @@index([nextCalculationAt])
}
